# Solid.js Hydration Analysis for Malloy Render

## Question

Can we pre-render HTML without disabling virtualization/SVG and have Malloy render plugins hydrate the existing DOM for interactivity?

## Answer: Not Currently Possible (Without Modifications)

### Why It Doesn't Work Out of the Box

**Current Malloy Render Implementation:**

```javascript
// From @malloydata/render (minified, annotated)
render(element) {
  // ...setup...

  // This is Solid.js render() - it REPLACES the element's content
  this.disposeFn = render(() => createComponent(MalloyRender, props), this.targetElement);
}
```

The `render()` function from `solid-js/web`:
- **Clears** the target element (`element.textContent = ""`)
- Creates new DOM nodes from scratch
- Does NOT reuse existing DOM

**What Hydration Requires:**

```javascript
import { hydrate } from "solid-js/web";

// hydrate() expects:
// 1. The DOM to EXACTLY match what renderToString() produced
// 2. Special markers (data-hk attributes, HTML comments) in the HTML
// 3. The same component tree that was used for SSR
hydrate(() => createComponent(MalloyRender, props), existingElement);
```

### The Fundamental Problem

Solid.js hydration requires the HTML to be generated by `renderToString()` or `renderToStringAsync()` with special markers that tell hydrate() where to attach reactivity:

```html
<!-- SSR output from Solid.js -->
<div data-hk="0">
  <!--#-->Static content<!--/-->
  <button data-hk="1">Click me</button>
</div>
```

If you pre-render HTML manually (even if it looks identical), hydration will fail because:
1. No `data-hk` attributes
2. No boundary comment markers (`<!--#-->`, `<!--/-->`)
3. No serialized state for reactive primitives

### What Would Be Required

To enable hydration in Malloy render, you would need:

#### Option A: Modify @malloydata/render

```typescript
// Add hydration support to MalloyViz
class MalloyViz {
  // New method for hydration
  hydrate(targetElement: HTMLElement): void {
    if (!this.result || !this.metadata) {
      throw new Error("No result to hydrate");
    }

    // Use solid-js hydrate instead of render
    import { hydrate } from "solid-js/web";

    this.disposeFn = hydrate(
      () => createComponent(MalloyRender, this.buildProps()),
      targetElement
    );
  }

  // Static method for SSR
  static renderToString(result: Result, options: MalloyRendererOptions): Promise<string> {
    import { renderToStringAsync } from "solid-js/web";

    return renderToStringAsync(() =>
      createComponent(MalloyRender, { result, ...options })
    );
  }
}
```

#### Option B: Custom SSR Pipeline

```typescript
// Server-side (build time)
import { renderToStringAsync } from "solid-js/web";
import { MalloyRender } from "@malloydata/render/component"; // Need internal access

const html = await renderToStringAsync(() =>
  createComponent(MalloyRender, {
    result: queryResult,
    tableConfig: { disableVirtualization: false }, // Keep virtualization!
    // ...other props
  })
);

// Client-side
import { hydrate } from "solid-js/web";
import { MalloyRender } from "@malloydata/render/component";

hydrate(
  () => createComponent(MalloyRender, props),
  document.getElementById("result-container")
);
```

### Challenges with Virtual Scroll + Hydration

Even with proper hydration support, virtual scroll presents unique challenges:

1. **Initial Visible Window**: SSR renders only visible rows (e.g., rows 0-20)
2. **Scroll Position**: On hydration, if user scrolled, positions don't match
3. **Dynamic Heights**: Row heights calculated at runtime may differ

```
Pre-rendered (rows 0-20):     After hydration + scroll:
┌──────────────────────┐      ┌──────────────────────┐
│ Row 0               │      │ Row 15              │
│ Row 1               │      │ Row 16              │
│ Row 2               │      │ Row 17              │
│ ...                 │      │ ...                 │
│ Row 20              │      │ Row 35              │
└──────────────────────┘      └──────────────────────┘
```

**Solution approaches:**
1. Pre-render with a larger window (e.g., 100 rows)
2. Show loading indicator for scrolled-past content
3. Use "progressive hydration" - hydrate visible area first

### Vega Charts and Hydration

Vega charts are slightly different - they render to `<canvas>` or `<svg>`:

**Canvas**: Cannot be hydrated (binary pixel data)
**SVG**: Could potentially be hydrated if:
- SVG is generated server-side via `vega.View.toSVG()`
- Event handlers are attached via delegation
- Tooltips/interactions are added client-side

```typescript
// Possible Vega hydration approach
const vegaSvg = await view.toSVG(); // Pre-render SVG

// On client, create Vega view that reuses SVG
const clientView = new vega.View(runtime)
  .initialize(existingContainer)  // Attach to existing DOM
  .hover()                        // Enable hover
  .run();                         // Activate interactions
```

### Recommendation

**Short-term**: Use `getHTML()` with `disableVirtualization: true` for pre-rendering. Accept that interactivity requires JS re-render.

**Medium-term**: Request feature from Malloy team to expose:
1. `renderToString()` static method
2. `hydrate()` instance method
3. Optional SSR-compatible mode

**Long-term**: Consider contributing hydration support to @malloydata/render:
1. Fork the package
2. Add SSR/hydration exports
3. Create PR upstream

### Code: Testing Hydration Feasibility

```typescript
// test-hydration.ts - Proof of concept

import { renderToStringAsync, hydrate } from "solid-js/web";
import { createSignal, createComponent } from "solid-js";

// Simple test component
function TestTable(props: { rows: string[] }) {
  const [selected, setSelected] = createSignal<number | null>(null);

  return (
    <table>
      <tbody>
        {props.rows.map((row, i) => (
          <tr
            class={selected() === i ? "selected" : ""}
            onClick={() => setSelected(i)}
          >
            <td>{row}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}

// Server-side render
const ssrHtml = await renderToStringAsync(() =>
  createComponent(TestTable, { rows: ["A", "B", "C"] })
);

// Output: <table data-hk="0"><tbody><!--#--><tr data-hk="1">...

// Client-side hydration
const container = document.getElementById("app");
container.innerHTML = ssrHtml;

hydrate(
  () => createComponent(TestTable, { rows: ["A", "B", "C"] }),
  container
);

// Now click handlers work on the pre-rendered HTML!
```

## Summary

| Approach | Works? | Notes |
|----------|--------|-------|
| Pre-render HTML, call `viz.render()` | ❌ | render() clears existing DOM |
| Pre-render HTML, call `hydrate()` | ❌ | No SSR markers in HTML |
| Use Solid.js SSR + hydrate | ⚠️ | Requires modifying Malloy render |
| Pre-render with `getHTML()` | ✅ | No interactivity, full static |
| Re-render on client | ✅ | Current approach, works but slower |

**Bottom line**: True hydration (pre-render + add interactivity) requires changes to @malloydata/render to expose Solid.js SSR capabilities.

## Sources

- [Solid.js hydrate documentation](https://docs.solidjs.com/reference/rendering/hydrate)
- [Solid.js SSR guide](https://www.solidjs.com/guides/server)
- [HydrationScript reference](https://docs.solidjs.com/reference/rendering/hydration-script)
